#summary One-sentence summary of this page.
#labels Phase-Implementation

= Introduction =

Why gwt-validition was not working in web mode after GWT 2.2.0 compilation.


= Details =

I went to a strange issues using GWT-Validation right after fixing the compilation for the GWT compiler.

Validation was working under development mode but almost all fields supposed to be validated went in error in WEB MODE, without any exception (nor nasty javascript alert boxes).

After investigation over the generated javascript it appeared thats several mistakes were causing this problems.

The first problem ame from the way Validators were implemented, the second from GWT compiler changes in GWT 2.2.0.

Here was the implementation of abstract validators, e.g. 'SizeValidatorAbstract.java':

{{{
...
	public boolean isValid(Object value) {
		if (value == null)
			return true;

		boolean valid = false;

		int size = -1;

		if (size < 0) {

			try {
				size = ((Object[]) value).length;
			} catch (Exception ex) {
				// ex.printStackTrace();
			}

		}

		if (size < 0) {

			try {
				size = ((int[]) value).length;
			} catch (Exception ex) {
				// ex.printStackTrace();
			}

		}
		...
}}}

This is translated in javascript, using GWT 2.2.0 compiler, as the following:

{{{
function $isValid_3(this$static, value){
  var $e0, size, valid;
  if (value == null)
    return true;
  valid = false;
  try {
    size = dynamicCast(value, 264).length;
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (!instanceOf($e0, 269))
      throw $e0;
  }
  if (size < 0) {
    try {
      size = dynamicCast(value, 388).length;
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (!instanceOf($e0, 269))
        throw $e0;
    }
  }
  ...
 }}}
 
 First of all, the Java catch block (eating the exception) in translated in javascript into a catch block throwing the error.
 So the behavior is different in java and javascript: in java the catch block is expected and is ignored, in javascript the algorithm is stopped and the error is thrown.
 
 humm ... so it might be the GWT compiler which changes a bit since the last version I used : GWT 2.0.4 ....?
 
 But, looking at the old javascript generated by the 2.0.4 compiler:
 
{{{
 function $isValid_3(this$static, value){
 var $e0, size, valid;
 if (value == null)
	return true;
 valid = false;
 size = -1;
 if (size < 0) {
	 try {
		size = dynamicCast(value, 264).length;
	 }
	 catch ($e0) {
		 $e0 = caught_0($e0);
		 if (!instanceOf($e0, 266))
			throw $e0;
	 }
 }
 if (size < 0) {
	try {
		size = dynamicCast(value, 386).length;
	 }
	 catch ($e0) {
		 $e0 = caught_0($e0);
		 if (!instanceOf($e0, 266))
			throw $e0;
	 }
 } 
 }}}
 
 Same exception thown !! How the hell it could worked in the past, and no longer now ?
 The answer is in the 'dynamicCast' function ... generated by GWT compiler, its implementation changed.
 
 Here is the old (2.0.4) javascript generated:
 
{{{
function dynamicCast(src, dstId){
 if (src != null && !canCastUnsafe(src.typeId$, dstId)) {
	throw $ClassCastException(new ClassCastException);
 }
 return src;
}

function canCastUnsafe(srcId, dstId){
	return srcId && typeIdArray[srcId][dstId];
}
}}}

'CanCastUnsafe' returned previously *undefined* which prevented the 'dynamicCast' function to throw the classCastException ... so ClassCastException was there, but not detected.
This has now been fixed by GWT 2.2.0 and so ClassCastException is returned by the DynamicCast function:

{{{
function dynamicCast(src, dstId){
  if (src != null && !(src.castableTypeMap$ && src.castableTypeMap$[dstId])) {
    throw new ClassCastException_0;
  }
  return src;
}
}}}
 
So this fix on the compiler breaks the actual way many Validators were implemented in gwt-validation: using class cast and expecting exception, catching it and continuing the algorithm.
This is no longer possible, so I refactored the Validators(Abstract) to use *instance of* instead of exceptions-expected approach.

